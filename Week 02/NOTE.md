## 总结

#### 寻路算法
1. 取出数组第一个元素，可以让它与最后一个交换位置，在用 `pop` 取出复杂程度O(1)
如果用 `spilce` 复杂程度O(n)
2. 寻路算法寻找的某个点的x、y与终点x、y差值越小意味着离终点越近可以优化寻路算法
理论上可以通过这种方法把点的优先级进行排序进行遍历查找

#### 算法总结
1、我们可以通过一个点的上下左右左边进行广度优先遍历最终查到终点，
用遍历的每个点的上一个点来标记路径

#### 二叉堆（个人理解）
`[3, 4, 5, 2, 1, 4, 5, 6]`

二叉堆排序后

`[1, 2, 4, 3, 4, 5, 5, 6]`                                     
1. 二叉堆是一种堆类型的二叉树结构
2. 二叉堆的子节点都大于（或小于）等于父节点,如果父节点大于等于左右节点这种被称为最大堆
反之则是最小堆
3. 取出某个节点的左侧节点对应公式 `2 * index + 1` 右侧节点 `2 * index + 2` 
父节点 `Math.floor((index - 1) / 2)`
4. 常用操作上浮下沉当我们新push一个元素，这个时候需要对该元素找到对应的父节点进行上浮/下沉等操作
5. 因为最小堆第一个值一定是最小的，所以这个我们取最小值比起 `Sorted` 不用再进行O(n)的排序
算出最小值

#### TODO A* 算法优化
